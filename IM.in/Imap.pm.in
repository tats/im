# -*-Perl-*-
################################################################
###
###			       Imap.pm
###
###	      Copyright (C) 1997  Internet Message Group
###
###		     This Perl5 library conforms
###		GNU GENERAL PUBLIC LICENSE Version 2.
###
###
### Author:  Internet Message Group <img@mew.org>
### Created: Apr 23, 1997
### Revised: @im_revised@
###

my $PM_VERSION = "IM::Imap.pm @im_version@";

package IM::Imap;
require 5.003;
require Exporter;

use IM::Config;
use IM::TcpTransaction;
use IM::GetPass;
use IM::MsgStore;
use IM::Scan;
use integer;
use strict;
use vars qw(@ISA @EXPORT);

@ISA = qw(Exporter);
@EXPORT = qw(
    imap_open imap_close imap_select imap_head imap_from imap_get imap_put
    imap_delete imap_copy imap_flags
    imap_list_folder imap_create_folder imap_delete_folder imap_rename_folder
    imap_get_msg imap_process imap_spec imap_scan_folder
);

=head1 NAME

Imap - IMAP handling package

=head1 SYNOPSIS

=head1 DESCRIPTION

=cut

use vars qw(*IMAPd $ImapSeq);
########################
# IMAP access routines #
########################

# imap_open(auth, host, user, pass)
#	return value:
#		 0: success
#		-1: failure
#
sub imap_open ($$$$) {
    my ($auth, $host, $user, $pass) = @_;
    my ($data, $seq, $errmsg);
    my (@host_list) = ($host);

    $pass = '*' unless ($pass);
    $ImapSeq = 100 unless ($ImapSeq);
    $seq = $ImapSeq++;
    im_notice("opening IMAP session\n");
    &tcp_logging(0);
    *IMAPd = &connect_server(\@host_list, 'imap', 0);
    return -1 unless ($IMAPd);
    my $resp = &send_command(\*IMAPd, '', '');
    if ($resp !~ /^\* OK/i) {
	im_warn($resp);
	return -1;
    }
    my $failed = 0;
    if ($auth eq 'LOGIN') {
	my $pw = $pass;
	if ($pw =~ / /) {		# if space included
	    $pw =~ s/([\\"])/\\$1/g;	# escape specials
	    $pw = "\"$pw\"";		# quote it
	}
	$resp = &send_command(\*IMAPd, "im$seq LOGIN $user $pw",
	  "im$seq LOGIN $user PASSWORD");
	while ($resp !~ /^im$seq/) {
	    if ($resp =~ /^\* NO/i) {
#		$failed = 1;
		$errmsg = $resp;
	    }
	    $resp = &next_response(\*IMAPd);
	}
    } else {
	require IM::EncDec && import IM::EncDec;
	$resp = &send_command(\*IMAPd, "im$seq AUTHENTICATE LOGIN", '');
	if ($resp =~ /^\+ (.*)/) {
	    $data = &b_decode_string($1);
	    im_debug("got \"$data\"\n") if (&debug('imap') || &verbose);
	} else {
	    $failed = 1;
	    $errmsg = $resp;
	}
	if (!$failed) {
	    $data = &b_encode_string($user);
	    im_debug("sending $user with base64 encoding.\n")
	      if (&debug('imap') || &verbose);
	    $resp = &send_command(\*IMAPd, $data,
	      "Base64-encoded-username($user)");
	    if ($resp =~ /^\+ (.*)/) {
		$data = &b_decode_string($1);
		im_debug("got \"$data\"\n") if (&debug('imap') || &verbose);
	    } else {
		$failed = 1;
		$errmsg = $resp;
	    }
	}
	if (!$failed) {
	    $data = &b_encode_string($pass);
	    im_debug("sending PASSWORD with base64 encoding.\n")
	      if (&debug('imap') || &verbose);
	    $resp = &send_command(\*IMAPd, $data, "Base64-encoded-password");
	}
	while ($resp !~ /^im$seq/) {
	    if ($resp =~ /^\* NO/i) {
#		$failed = 1;
		$errmsg = $resp;
	    }
	    $resp = &next_response(\*IMAPd);
	}
    }
    if ($resp !~ /^im$seq OK/) {
	$errmsg = $resp;
	$errmsg =~ s/^im$seq\s+NO\s*//i;
	im_warn($errmsg);
	return -1
    }
    return -1 if ($failed);
    return 0;
}

sub imap_close () {
    my ($seq) = $ImapSeq++;
    my $failed = 0;
    if (0) {
	im_notice("closing IMAP session.\n");
	my $resp = &send_command(\*IMAPd, "im$seq CLOSE", '');
	while ($resp !~ /^im$seq/) {
	    $failed = 1 if ($resp =~ /^\* NO/i);
	    $resp = &next_response(\*IMAPd);
	}
	return -1 if ($resp !~ /^im$seq OK/);
#	return -1 if ($failed);
	$seq = $ImapSeq++;
	$failed = 0;
    }
    my $resp;
    $resp = &send_command(\*IMAPd, "im$seq LOGOUT", '');
    while ($resp !~ /^im$seq/) {
	$failed = 1 if ($resp =~ /^\* NO/i);
	$resp = &next_response(\*IMAPd);
    }
    return -1 if ($resp !~ /^im$seq OK/);
#   return -1 if ($failed);
    close(IMAPd);
    return 0;
}

sub imap_select ($$) {
    my ($mbox, $select) = @_;
    my ($seq) = $ImapSeq++;
    my ($resp, @field);
    if ($select) {
	im_notice("select mbox $mbox and getting number of message.\n");
	$resp = &send_command(\*IMAPd, "im$seq SELECT $mbox", '');
    } else {
	im_notice("examine mbox $mbox and getting number of message.\n");
	$resp = &send_command(\*IMAPd, "im$seq EXAMINE $mbox", '');
    }
    my $msgs = -1;
    my $failed = 0;
    while ($resp =~ /^\*/) {
	@field = split(' ', $resp);
	if ($field[1] =~ /^ok$/i) {
	} elsif ($field[1] =~ /^no$/i) {
	    $failed = 1;
	} elsif ($field[1] =~ /^flags$/i) {
	} elsif ($field[2] =~ /^exists$/i) {
	    $msgs = $field[1];
	} elsif ($field[2] =~ /^recent$/i) {
	}
	$resp = &next_response(\*IMAPd);
    }
    return -1 if ($resp !~ /^im$seq OK \[READ-WRITE\]/i);
#   return -1 if ($failed);
    return -1 if ($msgs < 0);
    im_notice("$msgs message(s) found.\n");
    return $msgs;
}

sub imap_get ($) {
    my ($num) = @_;
    my ($seq) = $ImapSeq++;
    my (@message);
    im_notice("getting message $num.\n");
    my $resp = &send_command(\*IMAPd, "im$seq UID FETCH $num RFC822", '');
    my $failed = 0;
    if ($resp =~ /^\* \d+ FETCH \((UID $num )?RFC822 \{(\d+)\}/i) {
	my $size = $2;
	alarm(20) unless win95p();
	$! = 0;
	while (<IMAPd>) {
	    unless (win95p()) {
		alarm(0);
		if ($!) {   # may be channel truoble
		    im_warn("lost connection for FETCH(get).\n");
		    return (-1, 0);
		}
	    }
	    $size -= length($_);
	    s/\r\n$/\n/;
	    im_debug($_) if (&debug('imap'));
	    push (@message, $_);
	    last if ($size <= 0);
	}
	alarm(0) unless win95p();
	$resp = &next_response(\*IMAPd);
	return (-1, 0) if ($resp !~ /^\)/ &&
			   $resp !~ /^( FLAGS \(.*\)| UID $num)+\)/);
    } elsif ($resp =~ /^im$seq OK/) {
	return (1, 0);
    } else {
	$failed = 1;
	im_warn("UID FETCH command failed.\n");
    }
    $resp = &next_response(\*IMAPd);
    return (-1, 0) if ($resp !~ /^im$seq OK/);
#   return (-1, 0) if ($failed);
    return (0, \@message);
}

sub imap_head ($) {
    my ($num) = @_;
    my ($seq) = $ImapSeq++;
    im_notice("getting header of message $num.\n");
    my $resp = &send_command(\*IMAPd,
      "im$seq UID FETCH $num (RFC822.SIZE RFC822.HEADER)", '');
    my $failed = 0;
    my (%head);
    undef %head;
    if ($resp =~
    /^\* \d+ FETCH \((UID $num )?RFC822.SIZE (\d+) RFC822.HEADER \{(\d+)\}/i) {
	my ($size, $len) = ($2, $3);
	my $field = '';
	alarm(20) unless win95p();
	$! = 0;
	while (<IMAPd>) {
	    unless (win95p()) {
		alarm(0);
		if ($!) {   # may be channel truoble
		    im_warn("lost connection for FETCH(head).\n");
		    return (-1, 0);
		}
	    }
	    $len -= length($_);
	    s/\r?\n$//;
	    im_debug("$_\n") if (&debug('imap'));

	    if (/^\s/) {
		s/^\s+//;
		$head{$field} = $head{$field} . $_;
		last if ($len <= 0);
		next;
	    } elsif (/^([^:]+):\s*(.*)/) {
		$field = lc($1);
		$head{$field} = $2;
	    } else {
#		$inheader = 0;
		last if ($len <= 0);
		next;
	    }
	    last if ($len <= 0);
	}
	alarm(0) unless win95p();
#	$head{'bytes:'} = $size;
	$head{'kbytes:'} = int(($size + 1023) / 1024);
	$resp = &next_response(\*IMAPd);
	return (-1, 0) if ($resp !~ /^\)/ && $resp !~ /^ UID $num\)/);
    } elsif ($resp =~ /^im$seq OK/) {
	return (1, 0);
    } else {
	$failed = 1;
	im_warn("UID FETCH command failed.\n");
    }
    $resp = &next_response(\*IMAPd);
    return (-1, 0) if ($resp !~ /^im$seq OK/);
#   return (-1, 0) if ($failed);
    return (0, \%head);
}

sub imap_from ($) {
    my ($num) = @_;
    my $seq = $ImapSeq++;
    my $failed = 0;
    im_notice("getting sender information of message $num.\n");
#   my $resp = &send_command(\*IMAPd,
#     "im$seq UID FETCH $num RFC822.HEADER.LINES (From Date Subject)", '');
    my $resp = &send_command(\*IMAPd,
      "im$seq UID FETCH $num RFC822.HEADER.LINES (From)", '');
    if ($resp =~ /^\* \d+ FETCH \((UID $num )?RFC822.* \{(\d+)\}/i) {
	my $size = $2;
	my $found = 0;
	my $f;
	alarm(20) unless win95p();
	$! = 0;
	while (<IMAPd>) {
	    unless (win95p()) {
		alarm(0);
		if ($!) {   # may be channel truoble
		    im_warn("lost connection for FETCH(from).\n");
		    return -1;
		}
	    }
	    $size -= length($_);
	    s/\r\n$/\n/;
	    im_debug($_) if (&debug('imap'));
	    if ($f eq '' && /^From:\s*(.*)/i) {
		$found = 1;
		$f = $1;
	    } elsif (/^\s/ && $found) {
		$f .= $_;
	    } else {
		$found = 0;
	    }
	    last if ($size <= 0);
	}
	alarm(0) unless win95p();
	$f =~ s/\n[ \t]*/ /g;
	$f = '(sender unknown)' unless ($f);
	print "From $f\n";
	$resp = &next_response(\*IMAPd);
	return -1 if ($resp !~ /^\)/ && $resp !~ /^ UID $num\)/);
    } elsif ($resp =~ /^im$seq OK/) {
	return 1;
    } else {
	$failed = 1;
	im_warn("UID FETCH command failed.\n");
    }
    $resp = &next_response(\*IMAPd) if ($resp !~ /^im$seq/);
    return -1 if ($resp !~ /^im$seq OK/);
#   return -1 if ($failed);
    return 0;
}

sub imap_flags ($) {
    my ($num) = @_;
    my $seq = $ImapSeq++;
    my ($flags);
    im_notice("getting flags for $num.\n");
    my $failed = 0;
    my $resp = &send_command(\*IMAPd, "im$seq UID FETCH $num FLAGS", '');
    while ($resp !~ /^im$seq/) {
	if ($resp =~ /^\* NO/i) {
	    $failed = 1;
	} elsif ($resp =~ /^\* \d+ FETCH \(UID $num FLAGS \((.*)\)\)/i ||
		 $resp =~ /^\* \d+ FETCH \(FLAGS \((.*)\) UID $num\)/i) {
	    $flags = $1;
	}
	$resp = &next_response(\*IMAPd);
    }
    return '' if ($resp !~ /^im$seq OK/);
    return '' if ($failed);
    return $flags;
}

sub imap_delete ($) {
    my ($num) = @_;
    my $seq = $ImapSeq++;
    my $failed = 0;
    im_notice("deleting message $num.\n");
    my $resp = &send_command(\*IMAPd,
	"im$seq UID STORE $num +FLAGS (\\Deleted)", '');
    while ($resp !~ /^im$seq/) {
	$failed = 1 if ($resp =~ /^\* NO/i);
	$resp = &next_response(\*IMAPd);
    }
    return -1 if ($resp !~ /^im$seq OK/);
#   return -1 if ($failed);
    return 0;
}

sub imap_list_folder () {
    my $seq = $ImapSeq++;
    my $failed = 0;
    im_notice("listing folders.\n");
    my $resp = &send_command(\*IMAPd, "im$seq LIST \"\" *", '');
    my (@folders) = ();
    while ($resp !~ /^im$seq/) {
	$failed = 1 if ($resp =~ /^\* NO/i);
        if ($resp =~ /^\* LIST \(([^)]*)\) (\S+) (\S+)/) {
            # \NoSelect should be skipped. but exclusive with \NoInferiors?
            push(@folders, $3)
              if (grep('\\NoInferiors' eq $_, split(' ', $1)));
        }
	$resp = &next_response(\*IMAPd);
    }
    return -1 if ($resp !~ /^im$seq OK/);
#   return -1 if ($failed);
    return @folders;
}

sub imap_create_folder ($) {
    my ($folder) = @_;
    my $seq = $ImapSeq++;
    my $failed = 0;
    im_notice("creating folder $folder.\n");
    my $resp = &send_command(\*IMAPd, "im$seq CREATE $folder", '');
    while ($resp !~ /^im$seq/) {
	$failed = 1 if ($resp =~ /^\* NO/i);
	$resp = &next_response(\*IMAPd);
    }
    return -1 if ($resp !~ /^im$seq OK/);
#   return -1 if ($failed);
    return 0;
}

sub imap_delete_folder ($) {
    my ($folder) = @_;
    my $seq = $ImapSeq++;
    my $failed = 0;
    im_notice("deleting folder $folder.\n");
    my $resp = &send_command(\*IMAPd, "im$seq DELETE $folder", '');
    while ($resp !~ /^im$seq/) {
	$failed = 1 if ($resp =~ /^\* NO/i);
	$resp = &next_response(\*IMAPd);
    }
    return -1 if ($resp !~ /^im$seq OK/);
#   return -1 if ($failed);
    return 0;
}

sub imap_rename_folder ($$) {
    my ($old, $new) = @_;
    my $seq = $ImapSeq++;
    my $failed = 0;
    im_notice("rename folder from $old to $new.\n");
    my $resp = &send_command(\*IMAPd, "im$seq RENAME $old $new", '');
    while ($resp !~ /^im$seq/) {
	$failed = 1 if ($resp =~ /^\* NO/i);
	$resp = &next_response(\*IMAPd);
    }
    return -1 if ($resp !~ /^im$seq OK/);
#   return -1 if ($failed);
    return 0;
}

sub imap_copy ($$$) {
    my ($srcmsg, $dstfolder, $moveflag) = @_;
    im_notice("copying message $srcmsg to $dstfolder.\n");
    my $resp = &imap_select($dstfolder, 0);
    if ($resp < 0) {
        $resp = &imap_create_folder($dstfolder);
	if ($resp < 0) {
	    im_err("can't create folder $dstfolder.\n");
	    return -1;
	}
    }
    my $seq = $ImapSeq++;
    my $failed = 0;
    $resp = &send_command(\*IMAPd, "im$seq UID COPY $srcmsg $dstfolder", '');
    while ($resp !~ /^im$seq/) {
	$failed = 1 if ($resp =~ /^\* NO/i);
	$resp = &next_response(\*IMAPd);
    }
    return -1 if ($resp !~ /^im$seq OK/);
#   return -1 if ($failed);
    if ($moveflag) {
	$resp = &imap_delete($srcmsg);
    }
    return -1 if ($resp < 0);
    return 0;
}

sub imap_put ($$) {
    my ($folder, $Msg) = @_;
    my $seq = $ImapSeq++;
    my $failed = 0;
    im_notice("appending a new message to $folder.\n");
    my $size = 0;
    foreach (@$Msg) {
	s/\r?\n?$/\r\n/;
	$size += length($_);
    }
    my $resp = &send_command(\*IMAPd,
      "im$seq APPEND $folder (\\Seen) {$size}", '');
    if ($resp =~ /^\+/) {	# + Ready for argument
	foreach (@$Msg) {
	    send_data(\*IMAPd, $_, '');
	}
	send_data(\*IMAPd, '', '');
    }
    while ($resp !~ /^im$seq/) {
	$failed = 1 if ($resp =~ /^\* NO/i);
	$resp = &next_response(\*IMAPd);
    }
    $failed = 1 if ($resp !~ /^im$seq OK/);
    # synchronize
    $seq = $ImapSeq++;
    $resp = &send_command(\*IMAPd, "im$seq NOOP", '');
    while ($resp !~ /^im$seq/) {
	$failed = 1 if ($resp =~ /^\* NO/i);
	$resp = &next_response(\*IMAPd);
    }
    $failed = 1 if ($resp !~ /^im$seq OK/);
#   return -1 if ($failed);
    return 0;
}

# imap_process(how, host, src, dst)
sub imap_process ($$$$) {
    my ($how, $host, $src, $dst) = @_;
    my ($msgs);
    return -1 if (($msgs = &imap_select($src, 1)) < 0);
    if ($how eq 'check') {
	if ($msgs > 0) {
	    im_msg("$msgs message(s) at $host.\n");
	} else {
	    im_msg("no message at $host.\n");
	}
    } elsif ($how eq 'from') {
	if ($msgs > 0) {
	    my @alluids = &imap_all_uids();
	    return -1 if ($alluids[0] < 0);
	    my $i;
	    foreach $i (@alluids) {
		return -1 if (&imap_from($i) < 0);
	    }
	    im_info("$msgs message(s) at $host.\n");
	} else {
	    im_info("no message at $host.\n");
	}
    } elsif ($how eq 'get') {
	if ($msgs > 0) {
	    im_info("Getting new messages from $host into $dst....\n");
	    my @alluids = &imap_all_uids();
	    return -1 if ($alluids[0] < 0);
	    my $i;
	    foreach $i (@alluids) {
		my ($rc, $message) = &imap_get($i);
		return -1 if ($rc < 0);
		return -1 if (&store_message($message, $dst) < 0);
		&exec_getsbrfile($dst);
		unless ($main::opt_keep) {
		    return -1 if (&imap_delete($i) < 0);
		}
	    }
	    im_info("$msgs message(s).\n");
	} else {
	    im_info("no messages at $host.\n");
	}
    }
    return $msgs;
}

sub imap_get_msg ($$$) {
    my ($src, $dst, $how) = @_;

    $src =~ s/^imap//i;

    my ($folder, $auth, $user, $host) = &imap_spec($src);
    return -1 if ($folder eq '');

    my $pass = '';
    my $agtfound = 0;
    my $interact = 0;
    if (&usepwagent()) {
	$pass = &loadpass('imap', $auth, $host, $user);
	$agtfound = 1 if ($pass ne '');
    }
    if ($pass eq '' && &usepwfiles()) {
	$pass = &findpass('imap', $auth, $host, $user);
    }
    if ($pass eq '') {
	$pass = &getpass('Password: ');
	$interact = 1;
    }

    im_notice("accessing IMAP/$auth:$user\@$host for $how\n");
    if (&imap_open($auth, $host, $user, $pass) == 0) {
	&savepass('imap', $auth, $host, $user, $pass)
	    if ($pass ne '' && $interact && &usepwagent());
	my $msgs = &imap_process($how, $host, $folder, $dst);
	if ($msgs < 0) {
	    im_warn("IMAP processing error.\n");
	}
	&imap_close();
	return $msgs;
    } else {
	im_err("IMAP connection was not established.\n");
	&savepass('imap', $auth, $host, $user, '')
	    if ($agtfound && &usepwagent());
	return -1;
    }
}

# IMAP folder (--src=imap[%folder][:user][/auth][@server[/port]])
sub imap_spec ($) {
    my $spec = shift;

    if ($spec eq '') {
	my $s = imapaccount();
	if ($s !~ /^[\/\@:]/) {
	    if ($s =~ /\@/) {
		$s = ":$s";
	    } else {
		$s = "\@$s";
	    }
	}
	$spec = $s if ($s ne '');
    }

    my ($folder, $auth, $host) = ('INBOX', 'auth', 'localhost');
    my $user = $ENV{'USER'} || $ENV{'LOGNAME'} || login_name();

    while ($spec ne '') {
	if ($spec =~ /^%([^%:\@]+)(.*)/) {	# XXX
	    $folder = $1;
	} elsif ($spec =~ /^:([^%:\/\@]+)(.*)/) {
	    $user = $1;
	} elsif ($spec =~ /^\/([^%:\/\@]+)(.*)/) {
	    $auth = $1;
	} elsif ($spec =~ /^\@([^%\@]+)(.*)/) {
	    $host = $1;
	} else {
	    im_warn("invalid imap spec: $spec\n");
	    return ('', '', '', '');
	}
	$spec = $2;
    }

    if ($auth =~ /^auth$/i) {
	$auth = 'AUTH';
    } elsif ($auth =~ /^login$/i) {
	$auth = 'LOGIN';
    } else {
	im_warn("unknown authentication protocol: $auth\n");
	return ('', '', '', '');
    }

    return ($folder, $auth, $user, $host);
}

############################################
##
## For imls
##

sub imap_scan_folder ($@) {
    my ($folder, @ranges) = @_;
    my ($uid, $size, $len);

    my $msgset = &imap_range2set(@ranges);
    return  0 if !$msgset;
    return -1 if ($msgset < 0);
    my $count = 0;
    my $seq = $ImapSeq++;
    my $resp = &send_command(\*IMAPd,
	"im$seq UID FETCH $msgset (RFC822.SIZE RFC822.HEADER)", '');
    while ($resp =~
  /^\* \d+ FETCH \((UID (\d+) )?RFC822.SIZE (\d+) RFC822\.HEADER \{(\d+)\}/i) {
	($uid, $size, $len) = ($2, $3, $4);
	my @hdr;
	alarm(20) unless win95p();
	$! = 0;
	while (<IMAPd>) {
	    unless (win95p()) {
		alarm(0);
		if ($!) {   # may be channel truoble
		    im_warn("lost connection for FETCH(scan).\n");
		    return -1;
		}
	    }
	    $len -= length;
	    s/\r?\n$/\n/;
	    im_warn($_) if (&debug('imap'));
	    push(@hdr, $_);
	    last if ($len <= 0);
	}
	alarm(0) unless win95p();
	$resp = &next_response(\*IMAPd);
	if (!$uid) {
	    return -1 if ($resp !~ /^ UID (\d+)\)/);
	    $uid = $1;
	} else {
	    return -1 if ($resp !~ /^\)/);
	}

	my %Head;
	&store_header(\%Head, join('', @hdr));
#	$Head{'bytes:'} = $size;
	$Head{'kbytes:'} = int(($size + 1023) / 1024);
	$Head{'number'} = $uid;
	$Head{'folder'} = "\%$folder";
	parse_header(\%Head);

	if ($main::opt_thread) {
	    &make_thread(%Head);
	} else {
	    &disp_msg(\%Head);
	    $count++;
	}
	$resp = &next_response(\*IMAPd);
    }
    if ($resp !~ /^im$seq OK/) {
	im_warn("UID FETCH command failed.\n");
	return -1;
    }
    return $count;
}

sub imap_range2set (@) {
    my @ranges = @_;
    my (@uids, $fromuid, $dir);

    my @alluids = &imap_all_uids();
    return -1 if ($alluids[0] < 0);
    my ($min, $max) = ($alluids[0], $alluids[$#alluids]);

    @ranges = ('first-last') if ($#ranges < 0 || grep(/^all$/, @ranges));
    local $_;
    foreach (@ranges) {
	if (/^(\d+|first|last)-(\d+|first|last)$/) {
	    $fromuid = &imap_message_number($min, $max, $1);
	    if ($fromuid > $max) {
		$_ = '';
	    } else {
		$_ = "$fromuid:" . &imap_message_number($min, $max, $2);
	    }
	} elsif (/^(\d+|last|first):([+-]?)(\d+)$/) {
	    if ($1 eq 'last') {
		$dir = ($2 eq '+') ? +1 : -1;
	    } else {
		$dir = ($2 eq '-') ? -1 : +1;
	    }
	    $fromuid = &imap_message_number($min, $max, $1);
	    if ($dir > 0) {
		@uids = grep($_ >= $fromuid, @alluids);
		splice(@uids, $3) if ($3 < @uids);
	    } else {
		@uids = grep($_ <= $fromuid, @alluids);
		splice(@uids, 0, @uids - $3) if ($3 < @uids);
	    }
	    $_ = join(',', @uids);
	} elsif (/^(\d+|first|last)$/) {
	    $fromuid = &imap_message_number($min, $max, $1);
	    if ($fromuid > $max) {
		$_ = '';
	    } else {
		$_ = $fromuid;
	    }
	}
    }
    return join(',', grep($_, @ranges));
}

sub imap_all_uids () {
    my ($seq, $resp, @uids);

    $seq = $ImapSeq++;
    $resp = &send_command(\*IMAPd, "im$seq UID SEARCH 1:*", '');
    if ($resp =~ /^\* SEARCH (\d+( +\d+)*)/i) {
	@uids = split(' ', $1);
    } else {
	im_warn("UID SEARCH command failed.\n");
    }
    $resp = &next_response(\*IMAPd);
    return (-1) if ($resp !~ /^im$seq OK/);
    return @uids;
}

sub imap_message_number ($$$) {
    my ($min, $max, $num) = @_;

    return $num if $num =~ /^\d+$/;
    return $min if $num =~ /^first$/;
    return $max if $num =~ /^last$/;
    return '';
}

1;
