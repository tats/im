# -*-Perl-*-
################################################################
###
###			       Nntp.pm
###
###	      Copyright (C) 1997  Internet Message Group
###
###		     This Perl5 library conforms
###		GNU GENERAL PUBLIC LICENSE Version 2.
###
###
### Author:  Internet Message Group <img@mew.org>
### Created: Apr 23, 1997
### Revised: @im_revised@
###

my $PM_VERSION = "IM::Nntp.pm @im_version@";

package IM::Nntp;
require 5.003;
require Exporter;

use Fcntl;
use IM::Config;
use IM::TcpTransaction;
use integer;
use strict;
use vars qw(@ISA @EXPORT);

@ISA = qw(Exporter);
@EXPORT = qw(
    nntp_open
    nntp_close
    nntp_transaction
    nntp_article
    nntp_list
    nntp_command
    nntp_command_response
    nntp_next_response
    nntp_get_msg
    nntp_head_as_string
    nntp_spec
);

=head1 NAME

NNTP - NNTP interface package

=head1 SYNOPSIS

$return_code = &nntp_transaction(server_list, newsgroups,
    part_current, part_total);
$return_code = &nntp_close;

=head1 DESCRIPTION

=cut

use vars qw($Nntp_opened *NNTPd $NntpErrTitle);

##### NNTP SESSION OPENING #####
#
# nntp_open(server_list)
#	server_list:
#	return value:
#		 0: success
#		 1: recoverable error (should be retried)
#		-1: unrecoverable error
#
sub nntp_open ($$) {
    my ($servers, $logging) = @_;
    my $rc;

    if ($Nntp_opened) {
	return 0 if (grep(&get_cur_server() eq $_, @$servers));
	&nntp_close;
    }
    &tcp_logging($logging);
    *NNTPd = &connect_server($servers, 'nntp', 0);
    return 1 if ($NNTPd eq '');
    $NntpErrTitle = "(while talking to " . &get_cur_server() . " with nntp)\n";
    if ($rc = &tcp_command(\*NNTPd, '', '')) {
	return $rc;
    }
    my (@resp) = &command_response;
    if ($resp[0] =~ /InterNetNews server INN/) {
	return 1 if (&tcp_command(\*NNTPd, 'MODE reader', ''));
    }
    $Nntp_opened = 1;
    return 0;
}

##### NNTP SESSION CLOSING #####
#
# nntp_close()
#	return value:
#		 0: success
#		 1: recoverable error (should be retried)
#		-1: unrecoverable error
#
sub nntp_close () {
    return 0 unless ($Nntp_opened);
    $Nntp_opened = 0;
    im_notice("closing NNTP session.\n");
    return 1 if (&tcp_command(\*NNTPd, 'QUIT', ''));
    close(NNTPd);
    return 0;
}

##### NNTP TRANSACTION MANAGEMENT #####
#
# nntp_transaction(server_list, header, body, group, part, total)
#	server_list: list of NNTP servers
#	group: news group to be posted in
#	part: part number to be sent in partial message mode
#	total: total number of partial messages
#	return value:
#		 0: success
#		 1: recoverable error (should be retried)
#		-1: unrecoverable error
#
sub nntp_transaction ($$$$$$) {
    my ($servers, $Header, $Body, $group, $part, $total) = @_;
    my $rc;

    require IM::Log && import IM::Log;

    do {
	$rc = &nntp_transact_sub($servers, $Header, $Body, $part, $total);
	my (@resp) = &command_response;
	if ($rc) {
	    &im_warn($NntpErrTitle . join("\n", @resp) . "\n");
	    $NntpErrTitle = '';
	    &nntp_close;
	    &log_action('nntp', &get_cur_server(), $group,
			($#$servers >= 0) ? 'skipped' : 'failed', @resp);
	    return -1 if ($rc < 0);
	} else {
	    &log_action('nntp', &get_cur_server(), $group, 'sent', @resp);
	}
    } while ($rc > 0 && $#$servers >= 0);
    return $rc;
}

##### NNTP TRANSACTION MANAGEMENT SUBROUTINE #####
#
# nntp_transact_sub(server_list, part, total)
#	server_list: list of NNTP servers
#	part: part number to be sent in partial message mode
#	total: total number of partial messages
#	return value:
#		 0: success
#		 1: recoverable error (should be retried)
#		-1: unrecoverable error
#
sub nntp_transact_sub ($$$$$) {
    my ($servers, $Header, $Body, $part, $total) = @_;
    my $rc;

    return $rc if ($rc = &nntp_open($servers, 1));
    $rc = &tcp_command(\*NNTPd, 'POST', '');
    return -1 if ($rc < 0);
    if ($rc > 0) {
	my ($res) = &command_response();
	my ($user, $pass) = ('nouser', 'nopass');	# XXX
	if ($res =~ /^480/) {
	    # authenticate for posting
	    return $rc
	      if ($rc = &tcp_command(\*NNTPd, "AUTHINFO USER $user", ''));
	    return $rc
	      if ($rc = &tcp_command(\*NNTPd, "AUTHINFO PASS $pass",
		'AUTHINFO PASS ********'));
	} else {
	    return 1;
	}
    }

    select (NNTPd); $| = 0; select (STDOUT);

    require IM::Message && import IM::Message;

    &set_crlf("\r\n");
    if ($part == 0) {
	return 1 if (&put_header(\*NNTPd, $Header, 'nntp', 'all') < 0);
	return 1 if (&put_body(\*NNTPd, $Body, 1, 0) < 0);
    } else {
	return 1 if (&put_mimed_partial(\*NNTPd, $Header, $Body,
	  'nntp', 1, $part, $total) < 0);
    }
    select (NNTPd); $| = 1; select (STDOUT);
    return $rc if ($rc = &tcp_command(\*NNTPd, '.', ''));
    return 0;
}

sub nntp_head_as_string ($) {
    my $i = shift;
    my ($rc, $count) = ('', 0);
    local $_;

    im_notice("getting article $i.\n");
    $rc = &tcp_command(\*NNTPd, "HEAD $i", '');
    next if ($rc > 0);
    if ($rc < 0) {
	im_warn("HEAD command failed.\n");
	return -1;
    }
    $count++;
    my ($found, $f) = (0, '');
    alarm(20) unless win95p();
    $! = 0;
    while (<NNTPd>) {
	unless (win95p()) {
	    alarm(0);
	    if ($!) {   # may be channel truoble
		im_warn("lost connection for HEAD.\n");
		return -1;
	    }
	}
	s/\r\n$/\n/;
	last if ($_ =~ /^\.\n$/);
	s/^\.//;
	im_debug($_) if (&debug('nntp'));
	$f .= $_;
    }
    alarm(0) unless win95p();
    return $f;
}

sub nntp_head ($$) {
    my ($art_start, $art_end) = @_;
    local $_;
    my $count = 0;

    my $i;
    for ($i = $art_start; $i <= $art_end; $i++) {
	im_notice("getting article $i.\n");
	my $rc = &tcp_command(\*NNTPd, "HEAD $i", '');
	next if ($rc > 0);
	if ($rc < 0) {
	    im_warn("HEAD command failed.\n");
	    return -1;
	}
	$count++;
	my ($found, $f) = (0, '');
	alarm(20) unless win95p();
	$! = 0;
	while (<NNTPd>) {
	    unless (win95p()) {
		alarm(0);
		if ($!) {   # may be channel truoble
		    im_warn("lost connection for HEAD.\n");
		    return -1;
		}
	    }
	    s/\r\n$/\n/;
	    last if ($_ =~ /^\.\n$/);
	    s/^\.//;
	    im_debug($_) if (&debug('nntp'));
	    if ($f eq '' && /^From:\s*(.*)/i) {
		$found = 1;
		$f = $1;
	    } elsif (/^\s/ && $found) {
		$f .= $_;
	    } else {
		$found = 0;
	    }
	}
	$f =~ s/\n[ \t]*/ /g;
	$f = '(sender unknown)' unless ($f);
	print "From $f\n";
    }
    return $count;
}

sub nntp_xover ($$) {
    my ($art_start, $art_end) = @_;
    my $rc = &tcp_command(\*NNTPd, "XOVER $art_start-$art_end", '');

    if ($rc) {
	im_warn("XOVER command failed.\n");
	return -1;
    }
    my $count = 0;
    my ($resp);
    while (($resp = &next_response(\*NNTPd)) !~ /^\.$/) {
	$count++;
	my @overview = split('\t', $resp);

	# 0: article number
	# 1: Subject:
	# 2: From:
	# 3: Date:
	# 4: Message-ID:
	# 5: References:
	# 6: Bytes:
	# 7: Lines:

	print "From $overview[2]\n";
    }
    return $count;
}

sub nntp_article ($) {
    my $num = shift;
    local $_;
#   local (@Article);

    im_debug("getting article $num.\n") if (&debug('nntp'));
    my $rc = &tcp_command(\*NNTPd, "ARTICLE $num", '');
    return (1, '') if ($rc > 0);
    if ($rc < 0) {
	im_warn("ARTICLE command failed.\n");
	return (-1, '');
    }
    my @Article = ();
    alarm(20) unless win95p();
    $! = 0;
    while (<NNTPd>) {
	unless (win95p()) {
	    alarm(0);
	    if ($!) {   # may be channel truoble
		im_warn("lost connection for ARTICLE.\n");
		return (-1, '');
	    }
	}
	s/\r\n$/\n/;
	last if ($_ =~ /^\.\n$/);
	s/^\.//;
	push (@Article, $_);
	im_debug($_) if (&debug('nntp'));
    }
    alarm(0) unless win95p();
    return (0, \@Article);
}

sub nntp_articles ($$$$) {
    my ($art_start, $art_end, $dst, $limit) = @_;
    my ($rc, $article);
    my $count = 0;
    my $last = 0;

    my $i;
    for ($i = $art_start; $i <= $art_end; $i++) {
	($rc, $article) = &nntp_article($i);
	next if ($rc > 0);
	return -1 if ($rc < 0);
	$count++;

	require IM::MsgStore && import IM::MsgStore;
	return -1 if (&store_message($article, $dst) < 0);
	$last = $i;
	last if ($limit && --$limit == 0);
    }
    &exec_getsbrfile($dst);
    return ($count, $last);
}

sub nntp_list ($) {
    my $group = shift;
    local $_;

    my $rc = &tcp_command(\*NNTPd, 'LIST ACTIVE', '');
    if ($rc) {
	im_warn("LIST command failed.\n");
	return -1;
    }
    my $count = 0;
    my $resp;
    while (($resp = &next_response(\*NNTPd)) !~ /^\.$/) {
	next unless (/^$group/);
	$count++;
	print "$resp\n";
    }
    return $count;
}

sub nntp_command ($) {
    my $cmd = shift;
    return &tcp_command(\*NNTPd, $cmd, '');
}

sub nntp_command_response () {
    return &command_response;
}

sub nntp_next_response () {
    return &next_response(\*NNTPd);
}

sub set_last_article_number ($$$) {
    my ($server, $group, $number) = @_;
    my ($pos, $last, $size) = (0, 0, 0);

    my $nntphist = &nntphistoryfile() . '-' . $server;
    if ( -f $nntphist ) {
	open (NEWSHIST, "+<$nntphist");
	while ($pos = tell(NEWSHIST), $_ = <NEWSHIST>) {
	    /^([^:]+):\s*(\d+)/;
	    if ($group eq $1) {
		$last = $2;
		im_debug("$last articles in $group ($nntphist)\n")
		  if(&debug('nntp'));
		seek(NEWSHIST, $pos, 0);
		$size = length($_) - length("$group: 0000000\n");
		if ($size < 0) {
		    # no room to rewrite it
		    s/^./#/;
		    print NEWSHIST $_;
		    seek(NEWSHIST, 0, 2);
		    $size = 0;
		}
		last;
	    }
	}
    } else {
#	open (NEWSHIST, ">$nntphist");
	sysopen(NEWSHIST, $nntphist, O_RDWR|O_CREAT);
    }
    printf NEWSHIST "$group: %${size}s%07d\n", '', $number;
    close (NEWSHIST);
    return $last;
}

sub get_last_article_number ($$) {
    my ($server, $group) = @_;
    local $_;
    my $number = 0;

    my $nntphist = &nntphistoryfile() . '-' . $server;
    if (open (NEWSHIST, "<$nntphist")) {
	while (<NEWSHIST>) {
	    /^([^:]+):\s*(\d+)/;
	    if ($group eq $1) {
		$number = $2;
		last;
	    }
	}
	close (NEWSHIST);
    }
    return $number;
}

# returns number of got articles
# -1 if error
sub nntp_get_msg ($$$$) {
    my ($src, $dst, $how, $limit) = @_;
    my ($rc, $group, $error, $art_start, $art_end);
    my ($servers, @servers);

    if ($src =~ /^nntp:(.*)/i || $src =~ /^news:(.*)/i) {
	($group, $servers) = &nntp_spec($1);
	@servers = split(',', $servers);
    } else {
	im_warn("no news group specified ($src).\n");
	return -1;
    }

    im_notice("accessing to $group at $servers.\n");

    do {
	if (($rc = &nntp_open(\@servers, 0)) < 0) {
	    im_warn("Connection failed to $servers.\n");
	    return -1;
	}
	return -1 if (($rc = &nntp_command("GROUP $group")) < 0);
    } while (@servers > 0 && $rc > 0);
    return -1 if ($rc);

    my (@resp) = &command_response;
    $error = 0;
    my $i;
    for ($i = 0; $i <= $#resp; $i++) {
	if ($resp[0] =~ /^211 (\d+) (\d+) (\d+) (.*)$/) {
	    if ($4 ne $group) {
		# Should not occur
		$error = 1;
	    } else {
		$art_start = $2;
		$art_end = $3;
	    }
	    last;
	}
    }

    if ($error) {
	&nntp_close;
	return -1;
    }

    my ($art_last, $msgs);
    $art_last = &get_last_article_number($servers, $group);
    if ($art_end > $art_last) {
	# new articles
	if ($art_start < $art_last) {
	    $art_start = $art_last + 1;
	}
	$msgs = $art_end - $art_start + 1;
    } else {
	$msgs = 0;
    }

    if ($how eq 'skip') {
#	&nntp_close;
	my $last = &set_last_article_number($servers, $group, $art_end);
	if ($last < $art_end) {
	    my $num = $art_end - $last;
	    im_info("$num article(s) have been marked "
	      ."as read in $group at $servers.\n");
	} else {
	    im_info("no news in $group at $servers.\n");
	}
	return $msgs;
    }

    if ($how eq 'check') {
	if ($msgs > 0) {
	    im_info("$msgs news in $group at $servers.\n");
	} else {
	    im_info("no news in $group at $servers.\n");
	}
#	&nntp_close;
	return $msgs;
    }

    if ($how eq 'from') {
	if ($msgs > 0) {
	    $msgs = &nntp_xover ($art_start, $art_end);
	    $msgs = &nntp_head ($art_start, $art_end) if ($msgs < 0);
	    if ($msgs < 0) {
		im_warn("can not get article poster information.\n");
		return -1;
	    }
	im_info("$msgs article(s) in $group at $servers.\n");
	} else {
	    im_info("no news in $group at $servers.\n");
	}
#	&nntp_close;
	return $msgs;
    }

    if ($how eq 'get') {
	my ($last);
	if ($msgs > 0) {
	    im_info("Getting new messages from $group at $servers "
	      . "into $dst....\n");
	    ($msgs, $last) = &nntp_articles($art_start, $art_end, $dst, $limit);
	    if ($msgs < 0) {
		im_warn("can not get articles.\n");
		return -1;
	    }
	    im_info("$msgs messages(s).\n");
	} else {
	    im_info("no messages in $group at $servers.\n");
	}
#	&nntp_close;
	&set_last_article_number($servers, $group, $last) if ($last);
	return $msgs;
    }

    return -1;
}

# News group (-group[@server])
sub nntp_spec ($) {
    my $spec = shift;
    my ($group, $server);

    if ($spec =~ /([^@]*)\@(.*)/) {
	$group = $1;
	$server = $2;
    } else {
	$group = $spec;
	$server = &nntpservers();
    }
    return ($group, $server);
}

1;
